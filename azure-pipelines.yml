trigger:
- main

pool:
  vmImage: 'windows-latest'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  # Add custom packages path as global environment variable
  NUGET_PACKAGES: '$(Build.SourcesDirectory)/CustomPackages'

jobs:
- job: Build
  steps:
  # STEP 1: Add local folder as NuGet source
  - powershell: |
      # Create temporary NuGet config with local source
      $configContent = @"
      <?xml version="1.0" encoding="utf-8"?>
      <configuration>
        <packageSources>
          <add key="CustomPackages" value="$(Build.SourcesDirectory)/CustomPackages" />
          <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
        </packageSources>
      </configuration>
      "@
      Set-Content -Path "$(Build.SourcesDirectory)/nuget.temp.config" -Value $configContent
    displayName: 'Create temporary NuGet config'

  # STEP 2: Restore with custom config
  - task: NuGetCommand@2
    inputs:
      command: 'restore'
      restoreSolution: '$(solution)'
      feedsToUse: 'config'
      nugetConfigPath: '$(Build.SourcesDirectory)/nuget.temp.config'  # Use custom config
    displayName: 'NuGet restore with custom packages'

  # STEP 3: Build solution
  - task: VSBuild@1
    inputs:
      solution: '$(solution)'
      msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(build.artifactStagingDirectory)\WebApp.zip"'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  # ... rest of your tasks (test, publish artifacts)

  - task: VSTest@2
    inputs:
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: PublishBuildArtifacts@1
    inputs:
      pathtoPublish: '$(build.artifactStagingDirectory)'
      artifactName: 'drop'

- deployment: DeployToProduction
  displayName: 'Deploy to Production'
  environment: Production-Windows
  dependsOn: Build
  strategy:
    runOnce:
      deploy:
        steps:
        - download: current
          artifact: drop
          
        # Step 1: Start the website if it exists but is stopped
        - powershell: |
            Import-Module WebAdministration
            $siteName = "MyAPI"
            
            # Check if website exists
            if (Get-Website -Name $siteName) {
                # Start website if stopped
                $state = (Get-WebsiteState -Name $siteName).Value
                if ($state -eq "Stopped") {
                    Start-Website -Name $siteName
                    Write-Host "Started website: $siteName"
                }
                else {
                    Write-Host "Website $siteName is already running"
                }
            }
            else {
                Write-Error "Website $siteName does not exist"
            }
          displayName: 'Ensure Website is Running'

        # Step 2: Deploy application
        - task: IISWebAppDeploymentOnMachineGroup@0
          inputs:
            WebSiteName: 'MyAPI'
            Package: '$(Pipeline.Workspace)/drop/WebApp.zip'
            RemoveAdditionalFilesFlag: true
            TakeAppOfflineFlag: true
            ExcludeFilesFromAppData: false
            SetParametersFile: ''  # Add if you have custom parameters

        # Step 3: Verify deployment
        - powershell: |
            $siteName = "MyAPI"
            $state = (Get-WebsiteState -Name $siteName).Value
            $appPool = (Get-Website -Name $siteName).applicationPool
            $appPoolState = (Get-WebAppPoolState -Name $appPool).Value
            
            Write-Host "Website state: $state"
            Write-Host "AppPool state: $appPoolState"
            
            if ($state -ne "Started") {
                Write-Error "Website is not running after deployment"
            }
          displayName: 'Verify Deployment Status'